〇24章：アセンブリ言語

〇24.2：アセンブリ言語の記法
・メモリの転送サイズ(プレフィックス：DWORDなど)の指定が必要
　⇒レジスタの場合はレジスタ名でサイズが分かるので不要。メモリに即値を代入する場合は必須。
・[]の中で計算式を書けるが、3つ以上のレジスタは同時に使えないなどの制約がある

〇24.3：mov命令(代入命令)
・24.3.2の誤植：「rbxレジスタの値をrcxレジスタに代入せよ」はレジスタが逆。
・メモリからメモリへの転送はできない
・拡張mov命令：サイズの拡張。movsxd=mov+signed+extend+dword

〇24.4：lea命令(アドレス代入命令)
・第2オペランドには必ず[]が付くが、mov命令と違い、[]の指す先のデータではなく[]内の値がそのまま代入される
・[]の中で計算式を書けるので、その計算式の値をそのまま代入したい場合に使われる。

〇24.5：算術演算
・mul命令はオペランド1つのみ。演算結果は上半分がrdx、下半分がraxに入る。
・div演算も同様で、商がrax、あまりがrdxに入る。

〇24.8：比較
・cmp命令は内部で実行していることは引き算。その結果がフラグレジスタに入る。
　sub命令でもフラグレジスタは変わるので、違いはsubの計算結果が第一オペランドのレジスタに入るか否か。
・test命令はAND演算。

〇24.13：実践問題
・1. 3333(1111+1111+1111)
・2. jnzはZF=1なのでジャンプしない。3。
　　⇒mov命令でrdxは2→0に代わっている。なので1。
・3. movsxdは符号付(signed)なので、0xffffffff=-1。0x6020b8(0x6020c0-8)
・4. 0x12345678876543ff。alはraxの最下位1byteなので。
・5. -1(0xffffffffffffffff)。32ビットの演算は結果が自動的に64ビットに拡張されるということなので(x86-64の仕様とのこと)。
　　⇒拡張されるというのは、符号付き(signed)拡張でなくゼロ拡張なので、0xffffffffが入る。

〇25章：アセンブリを読んでみよう

〇25.4：関数呼び出し
・引数とレジスタの対応については、ここで記載。

〇25.7：実践問題
・1.
func(int a, int b){
    return (long)a * b;
}
⇒★bにもキャスト必要？
・2.
func(int a){
    if(a & 0x1){
        return 0;
    }else{
        return 1;
    }
}
⇒偶数判定という実装者の意図をくみ取るべきだった。
・3.
func(int a){
    int x=0;
    for(i=1; i<=a; i++){
        x+=i;
    }
    return x;
}

〇26章：静的解析に触れてみよう

〇26.2：IDAで開いてみる
・IDAの機能として、分岐の可視化ができる(Graph View)。

〇26.3：静的解析してみよう
・機械的に命名された変数名を意味にあうようにリネームして読みやすくしていく。

〇26.4：実践問題
・1. rbpの更新をしておらず、rspを移動しているだけ。引数もレジスタのまま使ってスタックに入れてない。
　★sub rsp, 0x8 の意味が分からない。スタックを使ってないはずなので、rspを更新しなくてもよいのでは。
　　⇒「メモリのアライメント制約」のコラム。x86-64の制約で、16byteアライメントのmov命令があるので、アライメントしている。
・2. スタックでなくレジスタから直接比較。jnzとjzなので極性が逆。パイプラインでジャンプしない方が早いはずで、2以外の可能性の方が高いのでそちらをジャンプなしにした？
・3. atoi が strtol に変わっている。printf は printf_chkに変わっている。0設定のときにXORを使っている。
　★printf_chkの前のEAXの0クリアはなぜ必要？これは最適化前にもある。
　　⇒printfが可変長引数なので。その場合、raxでベクトルレジスタの数を設定する仕様になっている。
　　　https://stackoverflow.com/questions/6212665/why-is-eax-zeroed-before-a-call-to-printf

〇27章：動的解析を組み合わせよう

〇27.2：IDAで静的解析する
・★push rbx は、rbxレジスタの変更が呼び出し元に影響しないように保存していると書いてあるが、なぜrbxレジスタだけ必要？→rbx以外は引数用に使うので。
　　あと、rbxレジスタの保存はこれまでなかったが、なぜこの関数だけやっている？→呼び出し元(main)でrbxレジスタを使っているためと思われる。
・★leave命令を使ってないのは、push rbxがあるからではないはず。pop rbx; leave; ret; とすればいいだけなので。理由は、rspを固定値(28h)で移動させているため。
　　mov rbp, rsp が必要なのは、関数内でrbpを使っているため(rbpからのオフセットでローカル変数にアクセス)。

〇27.3：gdbで動的解析する
・レジスタ値を見たり書き換えたりするコマンドは、info registers, set。

〇27.4：gdbスクリプトによる自動化
・gdb実行時に-xオプションをつけるとpythonで書かれたスクリプトでgdbを実行できる。
・コラム「gdbの仕組み」
　⇒linuxのptraceという機能を使っている(メモリやレジスタの読み書き)。
　⇒ブレークはx86_64の命令のint3命令を使っている(本来の命令をint3命令に上書きしておくと、SIGTRAPが発生するので、そこで一時停止できる。)。

〇27.5：実践問題
・1. b *0x40076f で 分岐の直前でブレークさせて、set $rip = 0x400771 で強制的に正解の方に分岐
・2. ctfの過去問で同様のことはやっているので、割愛(自分でC言語にしなくてもghidraのデコンパイル機能を使えばいい)
　　 ⇒c言語化した結果から、calc_password.pyを書いて、pythonで結果を計算している。

〇28章：より発展的な話題

〇28.1：プログラムにパッチを当てる
・コード28-1：patch.py
　- DIFファイルにあるアドレスはバイナリファイルの先頭からのオフセットなので、単純にその位置の1byteを書き換えるだけ。
　- バイナリファイルのサイズ変更はできないはず。1byte削除したり追加したり。

〇28.2：アンチデバッグ
・現在gdbが自プロセスにアタッチしているかどうかを調べる。gdbが使われているかを定期的にチェックして、使われていればプログラムを強制終了させるなどすればいい。
・手法1：ptraceで自分自身にアタッチして成功するか否か(戻り値が-1か否か)
・手法2：/proc/self/statusのTracerPidが0か否か

〇28.3：難読化
・

〇28.7：実践問題
・1.答えと思われるtracer_pid.cを見てしまったので、これを少し改変して、while()ループで、gdbを検出したら終了するプログラムにする。
・2.whileループで回して、一度見つけた解は除外する条件を追加すればいい。

〇32章：スタックベースエクスプロイト

〇32.2：攻撃手法

〇32.2.1：局所変数の改ざん
・スタックバッファオーバフローの脆弱性を使ってローカル変数を書き換える例
・ローカル変数がスタックのどの位置にあるかは、objdumpで逆アセンブルした結果から調べる。[rbp-0x??]というアセンブラがある。
・stringsコマンド
　⇒ある文字列がバイナリファイルのどのアドレスにあるかを検索
・★readelfの結果で「LOAD」文字列でgrepしてマッピングを見ているが、よくわからない
・★図32-5で、パディングが入っているが、下側のpriv、keyから入っていって、secretとnameはcharの配列なのでアライメントは不要では？
・pythonのprint(, end='') が分からない
　⇒デフォルトはend=改行なので、改行を入れないようにしている。
・ljustという文字列操作
　⇒引数で、全体の長さと、足りない場合のパディング値を指定すると、その長さでパディングで埋めた文字列を作ってくれる
・structライブラリのpack関数
　⇒バイナリデータを簡単につくれる
　⇒format引数：printfの%と似ている。この例では「<IQ」：リトルエンディアンで、一つ目はunsigned int、二つ目はunsigned long longでバイナリ化する。

〇32.2.2：リターンアドレスの改ざん
・ローカル変数でなくリターンアドレスを改ざんする例
・関数のアドレスを調べるのは、objdumpでもいいが、nmコマンドの方が簡単。※stripされていなければ。
・★コード32-17：RBPが0xdeadbeafになっているが、その状態でwin1関数にジャンプしても問題ない？win1に引数がないからrbpを使うことがないので大丈夫ということ？
・win1が終わった後にSegmentationFaultになるのはなぜ？
・★return addressは必ずrbp+0x8の位置にある？例えばコンパイラの最適化とかが入った場合とか。
・★リターンアドレスまでのオフセットを調べるための、gdb peda の cyclic pattern機能がよくわからない。
・★gdbは以下の標準入力に別プログラムの出力を与える、のコラムの目的がそもそもよくわからない。
　⇒入力を伴うプログラムをgdbでデバッグしたい場合？何回か行う前提なので、人がターミナルに入力するのはよくないということ？
　- rコマンド実行時に<でファイルからリダイレクトする
　- 通常のパイプは使えないので名前付きパイプを使う。別ターミナルから入力。
　- < <(command) を使う(プロセス置換という？)
　- <<<(command) を使う(ヒアストリングとコマンド置換)

〇32.2.3：Return-Oriented Programming
・x86-64は可変長命令なので(だいたいのアーキテクチャは効率を考えて可変長になっているはず)、実際にpop rdiという命令でなくても命令の一部がpop rdiの機械語である0x5fと一致すればいい。
　そのためのROPガジェットツール。
・ROPでは8byteずつスタックアドレスをずらしていくが、16byteアライメントの命令がある場合は、ROPでretのみの命令片を入れることで8byteずらして16byteアライメントにすればいい。
・pop rdiなどの引数を設定する命令片がない場合、第３引数までの設定であれば、libcの__libc_csu_init()という関数が使える。
　関数の途中～retまでをまずは実行し、次に関数の途中から実行すると、一旦r12～r14にpopした後、movでrdi(edi),rsi,rdxに入る。
　その後call命令でどこかの関数に飛ぶようにすればいい。r15+rxb*8
　- ★rbxは0に設定しておくとよいでしょう、とあるが、どうやる？→pop rbxがあるので、対応するスタックの位置に書いておけばいい。
　- r15には関数アドレスではなく、関数アドレスを格納しているメモリのアドレスを入れないといけない。つまり、スタックのアドレスがリークできてないといけない？
　　⇒というか、ASLRが無効でアドレスが固定であれば、アドレスリークは不要。
　　⇒ある関数が呼ばれているなら、その関数のアドレスが書いてあるはずで、そのアドレスを指定すればいいかと思ったが、call命令は今のアドレスからの相対アドレス指定なので、直接関数のアドレスが書いてあることはなさそう。
　　　なので、基本的にはスタックのアドレスが分かっているか、別のグローバル変数の書き換えができてないといけないはず。
　　　スタックのアドレスは、毎回変わるはずではあるが、処理が同じであれば大体同じになる気もするので、少なくとも確率的にはできそうではある。
　　⇒これが関数のアドレス自体を指定すればいいのであれば、逆に攻撃者に便利すぎて、何か対策を入れたくなるはずだが、多少不便なので放置されているということな気がする。
　　　⇒glibc 2.34で対策されている。
　- __libc_csu_init()とはどういう関数か
　　⇒静的に必ず組み込まれる(edge copilotに聞いた)ので、glibcのアドレスリークは不要。3引数の関数を呼ぶ処理があるので、そこで引数のレジスタ値へ設定する処理がある。
void __libc_csu_init(int argc, char **argv, char **envp) { // コンストラクタ関数の呼び出し for (size_t i = 0; i < __init_array_end - __init_array_start; i++) { __init_array_start[i](argc, argv, envp); } }
　- 「ret2csu」で検索
　　・https://gist.github.com/kaftejiman/a853ccb659fc3633aa1e61a9e26266e9
　　　⇒glibc ライブラリのバージョン 2.34 以降の変更により、__libc_csu_init 関数はバイナリに追加されなくなったらしい
　- 「glibc 2.34」
　　・https://compositecomputer.club/blog/37oVOzDji1pQQExTtmW0ts
　　　⇒__libc_csu_initを偲ぶ 〜さよなら俺達の後方互換〜
　　・https://hackmd.io/@t3mp/r1zt00V1j?utm_source=preview-mode&utm_medium=rec
　　　⇒glibc code reading 〜なぜ俺達のglibcは後方互換を捨てたのか〜

〇32.2.4：Stack Pivot
・

〇32.3 緩和機構

〇32.3.1 Stack Smash Protection(SSP)
・SSPが有効か無効かで、ローカル変数のスタック上の配置が変わる
　- ポインタや数値の変数は、書き替えられたくないので、一番トップに置かれるようになる
　- char型の配列が最も扱いやすいので、一番ボトムに置かれる
　- 分類内では、宣言順とかではなくサイズの大きいほうからボトムに置かれる。→★サイズが大きい方がバッファオーバフローしやすいため？
　- 同様の情報が書いてあるサイト(「Stack Smash Protection　ローカル変数」で検索)
　　propolice：スタックスマッシング攻撃検出手法の改良(pdf)
　　https://info.iar.com/ja/knowledge/learn/programming/stack-protection-in-iar-embedded-workbench
　- ★つまり、以前の32.1.1章での解釈は間違っている。ローカル変数を書き換えられることの方が危険。カナリアがないので。リターンアドレスはカナリアあるので比較的安全という考え。
・Thread Local Storage(TLS)
　- 静的もしくは大域的なメモリをスレッドごとに局所的に使用
　- ここにカナリアが置かれる。セグメントセレクタのfsを利用してアクセス。
　　⇒カナリアの値を、ほかのスレッドの脆弱性をついて見られることがないようにしている？
　- ★おそらく、直接アドレス指定ではアクセスできない領域？でも「通常通りDSを利用してアクセスすることも不可能ではありません」と書いてある
　　⇒デバッガでfsレジスタとかを見ればわかるかと思ったが、fsもdsもどちらも0だった。
　　　$cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00
・セグメント
　- https://hogetech.info/linux/kernel/memory
　　⇒セグメントとは、データの種類ごとの区分のことです。セグメント方式は、次のようにセグメント単位でプロセスを管理します。
　- https://qiita.com/sato4557/items/70c7b516c54f352c0b01
　　⇒Linux で基本的に利用されるコードセグメント、データセグメントは以下の 4 つのみである
　- https://inaz2.hatenablog.com/entry/2014/07/27/205913
　　⇒ももいろテクノロジー：ELF実行ファイルのメモリ配置はどのように決まるのか
　- https://qiita.com/deta-mamoru/items/7832af6c47359639df61
　　⇒セグメントレジスタについて(3.4.2 Segment Registers)
　　⇒各セグメントレジスタは、コード、データ、またはスタックの3種類のうちの1つに関連します
　　⇒FSはデータセグメントの中のとTLSの位置をオフセット0としてアクセスするためのレジスタと思われる。なのでデータセグメントには変わりないので、DSでもオフセットをうまく指定すればアクセスできる。
　　　★TLSのDSからのオフセットはわからないようになっている？
　- コード：CS、グローバル変数：DS、スタック：SS、ヒープ：ヒープはDSから参照？
・カナリア値
　- プログラムがexecされるたびに変化する乱数値
　- 先頭の1byte(little endianでは最下位byte)は必ず0(直前の文字列配列とつなげて文字列出力でカナリア値が流出するのを防ぐため)
　- プロセス内のすべての関数のカナリア値は同じ。(プロセスが変わればカナリア値も変わるはず)
・TCB(Thread Control Block)
　- https://stackoverflow.com/questions/62516740/differences-between-thread-control-block-and-thread-local-storage-and-which-one
　　⇒スレッド制御ブロックはメモリのブロックです。これは、スレッド固有のデータを保持するためにオペレーティング システム内に割り当てられます。
　　　スレッド ローカル ストレージはプログラミング手法です。スレッドにローカルなデータを使用することで構成します。
　- 先頭付近は構造体で配置が固定のため、カナリアは0x28固定の位置に置かれる。
　- プロセス開始時にlibcのsecurity_init()関数で設定。
・ELF Auxiliary Vectors
　- https://articles.manugarg.com/aboutelfauxiliaryvectors.html
　　⇒ELF 補助ベクトルは、特定のカーネル レベルの情報をユーザー プロセスに転送するメカニズムです。このような情報の例としては、メモリ内のシステム コール エントリ ポイントへのポインタ (AT_SYSINFO) があります。
　- 「補助ベクトルはスタック上にあり、環境変数よりもさらに上位に配置」なので、カナリア自体スタックなので、補助ベクトルをリークすることでカナリア値を特定するというのは難しそう。
　- 大本は、カーネルから提供されている疑似乱数。

〇32.3.2 ASLRとPIE

・ASLRとPIEの違い
　- https://zenn.dev/satoru_takeuchi/articles/d4839928e64cb4dca7eb
　　⇒ALSRによってスタック領域やヒープの領域のアドレスはどんなプロセスにおいてもランダム化されるのですが、コード領域や静的に配置されたグローバル変数やstatic変数などのデータ領域についてはそうではありません。
　- ASLRはシステム全体に適用されるもので、PIEはある実行バイナリだけに適用されるもの。
　- ASLRだけだとスタックやヒープのアドレスしかランダムにならない。ASLRかつPIEのバイナリであれば、コード領域やデータ領域も含めてすべてランダム化される。
　　逆に、PIEのバイナリであっても、ASLR無効であれば、基本は同じアドレスになるはず。たまたまほかのプログラムとの兼ね合いで別アドレスが割り当てられるかもしれないが。
・PIEとPICの違い
　- PICはコード(絶対アドレスでなく相対アドレスで書かれているコード)で、PIEは実行バイナリ
　- PIEであるためには、PICは必須。逆にPICだがPIEではない、というのは可能。なので、-picと-pieというオプションに分かれている。
・ASLRの有効無効切り替え
　- ★値1のときの、ヒープ以外有効(プログラムブレーク値が固定になる)　とは？

〇32.4 緩和機構の回避

〇32.4.1 canaryの特定
・xitetd → xinetd(エックスアイネットディー)のことと思われる。https://wa3.i-3-i.info/word13585.html
　- サービスに接続するごとに新たにプログラムがexecされる。
　- クラッシュするとカナリア値が変わるので、クラッシュさせずにリークが必要。
・コード32-45：sbof_leak.c
　- read()した文字列をdprintf()で出力。よくあるパターンではある。dprintf()は、ファイルディスクリプターに文字出力する。
　  ★ただ、カナリアをリークするだけでなくその後にクラッシュさせずにreturn address書き換えのためには、その後にさらにread()でバッファオーバフローが必要。
　- read()でバッファオーバフローしてカナリアの先頭の00を上書きして(16+9=25byte)、それ以降のカナリアの7byteを出力させる。
　- read()でなくfgets()だと、読み込み文字列の最後にヌル文字がつけられるので、うまくいかない。
　- この例では、saved rbpの最下位が00でそこでfprintf()が終わる想定。そうでなくもっと長くリークできる場合もあるはず。
・コード32-47：canaryのリーク
　- pythonのprint()で入力データを作っている。それをパイプでプログラムに入力している。プログラムの出力はxxdでバイナリで出力。
　- カナリアを1byte書き換えているため、当然stack smashing detectedでプログラムはクラッシュする。
・コード32-48：exploit_sbof_leak_canary.py
　- pwntoolsを使用。出力されたカナリア値を使って次のread()に入力しないといけないので、コマンドライン上でpythonを書くのはきつい。
　　https://qiita.com/8ayac/items/12a3523394080e56ad5a：Pwntoolsの機能と使い方まとめ【日本語】
　- context()：Pwntools内では対象のOSやアーキテクチャ、ビット幅などの設定はcontextというグローバル変数によって管理される
　- ELF()：パスを指定することで、ELFファイルを読み込める。ELFファイルが読み込まれると、ファイルのセキュリティ機構の情報がprintされる。
　　　　　 戻り値は、ELFファイル内の利用できるシンボルの情報を辞書型で保持。
　- process()：processを使うことでプロセスとやりとりできる。
　- sendafter()：sendafter(delim, data, timeout=default)→ str：A combination of recvuntil(delim, timeout=timeout) and send(data).
　  https://docs.pwntools.com/en/dev/tubes.html：pwnlib.tubes — Talking to the World!
　- recvuntil()：Receive data until one of delims is encountered.
　- recv(7)：recv(numb=4096, timeout=default)→ bytes：Receives up to numb bytes of data from the tube, and returns as soon as any quantity of data is available.
　- interactive()：interactive()を使うことで任意のプロセスとインタラクティブに通信ができる。
・fork-server：
　- 接続がくるたびにプログラムがforkをし、別プロセスとして動作。
　- メモリ環境およびカナリア値は何度接続しても一致する。
・最大256×7＝1792回の施行でカナリア値が分かる。
　- カナリアを、わかっている部分は同じ値を書いて、不明部分の最初の1byteだけ上書きして落ちなければその値が正解、というのを1byteずつ進ませる。

〇32.4.2 バイナリのベースアドレスの特定
・アドレスリークの案として、未初期化の変数を使うというものがある。
・コード32-50：スタック上のデータリーク
　- コード32-45のsbof_leak.cには、バッファオーバライトだけでなく情報漏洩の脆弱性もある。
　- read()ではヌル文字が自動で付かないので、buf[]の残りの不定値が次のdprintf()で出力される。
・コード32-51：リークした値の特定
　- gdb qオプション："静かに (Quiet)"。通常表示されるイントロダクション・メッセージを 表示しません
　　https://flex.phys.tohoku.ac.jp/texi/gdb-j/gdb-j_57.html
　- gdb-pedaでread()の直後でブレークさせて、そのときのスタックの値を確認。ポインタであればその先がなにかも表示してくれるので、buf[]の後半8byteには_start()のアドレスが入っているとわかる。
　- バイナリの先頭からのオフセットはnmやobjdumpでわかり、オフセットはASLRやPIEが有効でも変化しないため、、_start()のアドレスがリークできると、今回のバイナリのベースアドレスが計算できる。

〇32.5 実践問題
・read()+printf()が4回実行されるので、カナリア値のリーク、関数アドレスのリーク、スタックアドレスのリークをした上で、バッファオーバライトでリターンアドレスを書き換えらえる。
　- static-pieなので、PIEでありつつスタティックリンクなので、本体のアドレスリークができればglibcの関数のアドレスもわかる。
　　https://zenn.dev/tetsu_koba/articles/ecde4c6b5073bd
　- カナリア値のリークでカナリアを回避でき、リターンアドレスを書き換えられる。
　- 関数アドレスのリークで任意のROPガジェットが実行できる(glib含めて)。
　- スタックに"/bin/sh"を書いて、それをROPで第一引数のレジスタにpopして、次にsyscallのシステムコール番号がexecveになるようにraxレジスタにpopして、最後にsyscallを含むROPガジェットを実行。
　　https://qiita.com/sxarp/items/aff43dd83b0da69b92ce
　　https://www.mztn.org/lxasm64/x86_x64_table.html
・exploitコード
　- exploit += flat(rop.rdi.address, addr_stack) のように書けば、自分でROPガジェットを探さなくてもRDIレジスタとかにpopするROPガジェットを使ってくれるっぽい。
　　⇒事前に、binf = ELF(bin_file) と rop = ROP(binf)は必要。
　　　https://docs.pwntools.com/en/stable/rop/rop.html：pwnlib.rop.rop — Return Oriented Programming
　　　https://qiita.com/8ayac/items/12a3523394080e56ad5a：Pwntoolsの機能と使い方まとめ【日本語】
　　⇒★もしバイナリにpop rdi というROPガジェットがない場合はどうなる？
　- 1回目のread()で、0x19(=25)byte書き込むことで、カナリア値を漏洩。
　　⇒gdbで見ると、main()のsetbuf()の箇所でのスタック状況は、先頭8byteは不明なデータ、次の8byteは0データだが不明、で、その次がmsg[](アセンブラではrbp-0x20でアクセス)
　- 2回目のread()で、0x40(=64)byte書き込むことで、スタックのアドレスを漏洩
　　⇒gdbで見ると、以下
---
(gdb) dereference 0x00007fffffffe0d0 -l 32
0x00007fffffffe0d0│+0x0000: 0x00007fffffffe238  →  0x00007fffffffe4a4  →  "/home/parrot/work/files/pwnable/99_challs/stack/ch[...]"        ← $rsp
0x00007fffffffe0d8│+0x0008: 0x0000000000000000
0x00007fffffffe0e0│+0x0010: 0x0000000000000000
0x00007fffffffe0e8│+0x0018: 0x0000000000000000
0x00007fffffffe0f0│+0x0020: 0x0000000000000000
0x00007fffffffe0f8│+0x0028: 0x8eb0085cbfb79800
0x00007fffffffe100│+0x0030: 0x00007ffff7f3b180  →  <__libc_csu_init+0000> endbr64       ← $rbp
0x00007fffffffe108│+0x0038: 0x00007ffff7f3a9b0  →  <__libc_start_main+0490> mov edi, eax
0x00007fffffffe110│+0x0040: 0x0000000000000000
0x00007fffffffe118│+0x0048: 0x0000000100000000
0x00007fffffffe120│+0x0050: 0x00007fffffffe238  →  0x00007fffffffe4a4  →  "/home/parrot/work/files/pwnable/99_challs/stack/ch[...]"
0x00007fffffffe128│+0x0058: 0x00007ffff7f3a0c9  →  <main+0000> endbr64 
0x00007fffffffe130│+0x0060: 0x0000000000000000
0x00007fffffffe138│+0x0068: 0x0000000600000000
0x00007fffffffe140│+0x0070: 0x000000030000004e ("N"?)
0x00007fffffffe148│+0x0078: 0x0000000000000040 ("@"?)
0x00007fffffffe150│+0x0080: 0x0000000000000000
0x00007fffffffe158│+0x0088: 0x0000000000000000
0x00007fffffffe160│+0x0090: 0x0000000000000000
0x00007fffffffe168│+0x0098: 0x0000000000000000
0x00007fffffffe170│+0x00a0: 0x0000000000000000
0x00007fffffffe178│+0x00a8: 0x0000000000000000
0x00007fffffffe180│+0x00b0: 0x0000000000000000
0x00007fffffffe188│+0x00b8: 0x929ba74d49c51dec
0x00007fffffffe190│+0x00c0: 0x00007ffff7f3b220  →  <__libc_csu_fini+0000> endbr64 
0x00007fffffffe198│+0x00c8: 0x0000000000000000
0x00007fffffffe1a0│+0x00d0: 0x0000000000000000
0x00007fffffffe1a8│+0x00d8: 0x0000000000000000
0x00007fffffffe1b0│+0x00e0: 0x929bb755e8e51dec
0x00007fffffffe1b8│+0x00e8: 0x929ba74d78071dec
0x00007fffffffe1c0│+0x00f0: 0x0000000000000000
0x00007fffffffe1c8│+0x00f8: 0x0000000000000000
---
　　⇒0x00007fffffffe120にある、0x00007fffffffe238が漏洩。紫色なので、スタックのアドレス。一応、以下でそのアドレス付近のデータをダンプ。
---
(gdb) dereference 0x00007fffffffe200 -l 32
0x00007fffffffe200│+0x0000: 0x0000000000000000
0x00007fffffffe208│+0x0008: 0x0000000000000000
0x00007fffffffe210│+0x0010: 0x0000000000000000
0x00007fffffffe218│+0x0018: 0x00007ffff7f3a00e  →  <_start+002e> hlt 
0x00007fffffffe220│+0x0020: 0x00007fffffffe228  →  0x0000000000000000
0x00007fffffffe228│+0x0028: 0x0000000000000000
0x00007fffffffe230│+0x0030: 0x0000000000000001
0x00007fffffffe238│+0x0038: 0x00007fffffffe4a4  →  "/home/parrot/work/files/pwnable/99_challs/stack/ch[...]"
0x00007fffffffe240│+0x0040: 0x0000000000000000
0x00007fffffffe248│+0x0048: 0x00007fffffffe4e4  →  "SHELL=/bin/bash"    ← $rdx
0x00007fffffffe250│+0x0050: 0x00007fffffffe4f4  →  "WSL2_GUI_APPS_ENABLED=1"
0x00007fffffffe258│+0x0058: 0x00007fffffffe50c  →  "WSL_DISTRO_NAME=ParrotOS"
0x00007fffffffe260│+0x0060: 0x00007fffffffe525  →  "NMAP_PRIVILEGED="
0x00007fffffffe268│+0x0068: 0x00007fffffffe536  →  "NAME=DESKTOP-LNT7NI7"
0x00007fffffffe270│+0x0070: 0x00007fffffffe54b  →  "PWD=/home/parrot/work/files/pwnable/99_challs/stac[...]"
0x00007fffffffe278│+0x0078: 0x00007fffffffe57f  →  "LOGNAME=parrot"
0x00007fffffffe280│+0x0080: 0x00007fffffffe58e  →  "_=/usr/bin/gdb"
0x00007fffffffe288│+0x0088: 0x00007fffffffe59d  →  "LINES=67"
0x00007fffffffe290│+0x0090: 0x00007fffffffe5a6  →  "HOME=/home/parrot"
0x00007fffffffe298│+0x0098: 0x00007fffffffe5b8  →  "LANG=en_US.UTF-8"
0x00007fffffffe2a0│+0x00a0: 0x00007fffffffe5c9  →  "WSL_INTEROP=/run/WSL/9_interop"
0x00007fffffffe2a8│+0x00a8: 0x00007fffffffe5e8  →  "LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so[...]"
0x00007fffffffe2b0│+0x00b0: 0x00007fffffffeccc  →  "COLUMNS=253"
0x00007fffffffe2b8│+0x00b8: 0x00007fffffffecd8  →  "VIRTUAL_ENV=/home/parrot/mypy"
0x00007fffffffe2c0│+0x00c0: 0x00007fffffffecf6  →  "WAYLAND_DISPLAY=wayland-0"
0x00007fffffffe2c8│+0x00c8: 0x00007fffffffed10  →  "LESSCLOSE=/usr/bin/lesspipe %s %s"
0x00007fffffffe2d0│+0x00d0: 0x00007fffffffed32  →  "TERM=xterm-256color"
0x00007fffffffe2d8│+0x00d8: 0x00007fffffffed46  →  "LESSOPEN=| /usr/bin/lesspipe %s"
0x00007fffffffe2e0│+0x00e0: 0x00007fffffffed66  →  "USER=parrot"
0x00007fffffffe2e8│+0x00e8: 0x00007fffffffed72  →  "DISPLAY=:0"
0x00007fffffffe2f0│+0x00f0: 0x00007fffffffed7d  →  0x00313d4c564c4853 ("SHLVL=1"?)
0x00007fffffffe2f8│+0x00f8: 0x00007fffffffed85  →  "VIRTUAL_ENV_PROMPT=(mypy) "
---
　　⇒0x00007fffffffe238から0x158を引くと、0x00007fffffffe0e0で、msg[]の先頭アドレスになる。
　- 3回目のread()で、0x48(=72)byte書き込むことで、コードのアドレスを漏洩
　　⇒0x00007fffffffe128にある、0x00007ffff7f3a0c9が漏洩。赤色なのでコードのアドレス。<main+0000>なので、mainの先頭アドレスと思われる。
　　　そこから、mainの先頭のオフセット000000000000a0c9を引いて、バイナリの先頭アドレスを計算している。
　- ★このexploitは、main()が開始して直後の処理であり、スタックの状態が毎回同じであることを前提としている。
---
・ParrotOSで自分でchall_stackをビルドしてみる
　- exploitコードを実行するとエラーになる
　- objdumpの結果やgdbで見た感じ、そもそもカナリアが入っていない。
　　⇒-fstack-protectorをつける必要がありそう。
　- それにより、進んだが、SegFaultで落ちる
　　⇒gdbで見た感じ、カナリアの位置は変化なく、正しくとれていそう。
　　⇒exploitバイナリデータを解析。
　　　b"/bin/sh\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00`\xbdS\x81\xb9\x01\xe0\xef\xbe\xad\xde\x00\x00\x00\x00\x10\xfe\xc0\xa1\xf1\x7f\x00\x00@\xf9\x02\x9d\xff\x7f\x00\x00\xb2\xd2\xc1\xa1\xf1\x7f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x007\x89\xc7\xa1\xf1\x7f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'c\xc4\xa1\xf1\x7f\x00\x00;\x00\x00\x00\x00\x00\x00\x00b\xf2\xc0\xa1\xf1\x7f\x00\x00"
　　　2f62696e2f736800 ←/bin/sh
　　　0000000000000000 ←msg[]の後半
　　　0000000000000000 ←パディング
　　　0060bd5381b901e0 ←カナリア
　　　efbeadde00000000 ←saved rbp
　　　10fec0a1f17f0000 ←命令(0x9E10)：5f c3。pop    %rdi、ret
　　　40f9029dff7f0000 ←msg[]の先頭アドレスのはず。
　　　b2d2c1a1f17f0000 ←命令(0x172b2)：5e c3。pop    %rsi、ret
　　　0000000000000000 ←0
　　　3789c7a1f17f0000 ←命令(0x72937)：5a 5b c3。pop    %rdx、pop    %rbx、ret★
　　　0000000000000000 ←0
　　　2763c4a1f17f0000 ←命令(0x40327)：58 c3。pop    %rax、ret
　　　3b00000000000000 ←59なので、	execve
　　　62f2c0a1f17f0000 ←命令(0x9262)：0f 05                	syscall
　　　
　　　2f62696e2f736800
　　　0000000000000000
　　　0000000000000000
　　　00c99a65c56d0154
　　　efbeadde00000000
　　　10fe932d4d7f0000
　　　809fa203fe7f0000
　　　b2d2942d4d7f0000
　　　0000000000000000
　　　37899a2d4d7f0000
　　　0000000000000000
　　　7262780000000000 ★うまくrbxの分を入れられているが、それでもSegFaultになる
　　　2763972d4d7f0000
　　　3b00000000000000
　　　62f2932d4d7f0000
　　　
　　　※originalの方
　　　2f62696e2f736800
　　　0000000000000000
　　　0000000000000000
　　　00d901fef7d825e1
　　　efbeadde00000000
　　　3a6ca58ab37f0000
　　　90f287b4fc7f0000
　　　ce47a68ab37f0000
　　　0000000000000000
　　　3f6ba58ab37f0000 ★0x9b3f←命令：5a c3。pop    %rdx、ret
　　　0000000000000000
　　　276aaa8ab37f0000
　　　3b00000000000000
　　　4366a58ab37f0000
　　　
　　　2f62696e2f736800
　　　0000000000000000
　　　0000000000000000
　　　00ca6a63e465911e
　　　efbeadde00000000
　　　101ec8bcd07f0000
　　　b024feb8ff7f0000
　　　b2f2c8bcd07f0000
　　　0000000000000000
　　　37a9cebcd07f0000
　　　0000000000000000
　　　0000000000000000 ★うまくrbxの分を入れられているが、それでもSegFaultになる
　　　2783cbbcd07f0000
　　　3b00000000000000
　　　6212c8bcd07f0000
　- 「exploit += flat(rop.rdx.address, 0)」の行をコメントアウトすると、SegFaultせずにexploitが成功した
　　・execveの第三引数は、envpなので、0以外の値が入っているとそのアドレスにアクセスしてしまうので、今はたまたま成功しているだけ。
　　　⇒$strace -o  strace_exploit_satack_w_ssp.txt python exploit_stack_w_ssp.py
　　　　でsyscallでexecveを実行したときの引数が分かるかと思ったが、execveは最初のpython実行のものしかなかった。
　　　⇒-ffオプションをつけて子プロセスもstraceすると、strace_exploit_stack_w_ssp.txt.4112に、
　　　　execve("/bin/sh", NULL, NULL)　があり、たまたまrdxレジスタが0なのでうまくいっていると思われる。
　　・コメントアウトをもとに戻してSegFaultする場合は、やはりexecve()が呼ばれてない。pop rbxのせいでスタックがずれるので、
　　　本来の次のROPガジェット(pop rax)のアドレスをpop rbxして、次の0x3bがripに入ってそこにアクセスするのでSegFaultになる。
　　　⇒★ただ、なぜかshが1回だけ実行できる状態になるのが意味不明。
　　　　⇒conn.interactive()を実行しているからと思われる。これをコメントアウトすると、「$」プロンプトは出ない。
　　　　　上記をコメントアウトすると、exploitが成功する場合でも「$」プロンプトが出ずシェルが実行できない。
　　　　⇒例えば、attack(conn)だけをコメントアウトして、子プロセス起動してconn.interactive()だけ実行すると、
　　　　　Input (1/4) >> $ ls
　　　　　Output : ls
　　　　　のような感じになる。つまり、プログラムの標準入力へ「$」への入力がつながり、プログラムの標準出力が出力される。つまり対話状態。
　　　　　で、exploitできて、/bin/shが実行できれば、「$」への入力がそのまま/bin/shへの入力になり、コマンドとして実行されるということ。
　- ★process(bin_file)でなくgdb.debug(bin_file)で子プロセス起動すると、gdbserverが起動されてgdbしながらexplitができる
　　https://note.com/pien2021/n/nfad479f47da5
　　・

〇33章：共有ライブラリと関数呼び出し

〇33.1 ライブラリとリンク
・ライブラリについての基本的な説明。静的リンクと動的リンク。

〇33.2 関数の解決と利用

〇33.2.1 PLTとGOT
・PLTは実際はテーブルではなくjmpやpushなどからなるコード。GOTはコードでなく、アドレスのテーブル。
・コード33-2：printf()とputs()のみのシンプルなCソース
・コード33-3：objdumpのjオプションで.pltと.textのセクションのみ表示。
　　　　　　　main()のprintf()で0x401040にジャンプ。そこがprintf@plt。そこでGOTを参照してそこに入っているアドレスへジャンプする。
・コード33-4：gdbでprintf()にブレークを張って実行し、GOTをtelescopeで表示。
　　　　　　　printf()実行前にはGOTにはprintf()のアドレスではなくprintf@pltの次の命令(push 0x1)のアドレスが入っている。
　　　　　　　なので、printf()が呼ばれると、call(printf@plt), jmp(次の命令へ), push, jmp(.plt(PLTの先頭アドレス)), push, jmp(_dl_runtime_resolve_xsavec())が実行される。
・コード33-5：printf()実行後のGOTをtelescopeで表示。今度はprintf()のアドレスが入っている。
・遅延バインド。共有ライブラリの各関数は、初回に呼ばれたときはアドレス解決をされてGOTの書き換え＋関数呼び出しがされる。
　そのためにPLTをはさんでからGOTのアドレスにジャンプしている。直接GOTのアドレスにジャンプだと_dl_runtime_resolve_xsavec()に対して適切な引数を渡せないためと思われる。
　適切な引数を渡せないと、どの関数のアドレス解決をしたいかを指定できない。

〇33.2.2 発展　※一旦飛ばす。関数アドレスの解決にハッシュを使っているみたい。

〇33.3 攻撃手法

〇33.3.1 GOT Overwrite
・コード33-21：最初にfgets()でユーザに問い合わせ。AAR(任意アドレス読み出し＝アドレスを入力)かAAW(任意アドレス書き込み＝アドレスとデータを入力)を指定。
・コード33-22：readelfコマンドでexit()のGOTエントリのアドレスを取得、nmコマンドでwin()のアドレスを取得。あとはaarwのAAWを実行してそれらのアドレスを指定すればwin()が呼ばれる。
　　　　　　　★なぜwin()が呼ばれた後にsegmentation faultになる？
・コード33-23：win()でなくmain()に飛ぶようにすれば、任意アドレス書き込みが何回でもできるようになる。(Return to Vuln)

〇33.3.2 Return to PLT(ret2plt)
・コード33-24：readelfコマンドでatoi()のGOTエントリのアドレスを取得、objdumpコマンドでputs@pltのアドレスを取得。
　　　　　　　これで、aarwのAAWでこのアドレスを指定すると、atoi()実行時にatoi@plt→puts@plt→puts()の順にジャンプしてputs()が実行される。
　　　　　　　つまり、共有ライブラリのアドレスが分からなくても(アドレスリークできなくても)、共有ライブラリの任意の関数にジャンプできる(元々使用していてPLTにある関数のみ)。
　　　　　　　★あと、関数のとび先を変える場合、引数の数が違う場合は関数呼び出し規則のレジスタ値にたまたま入っている値が渡される。
・GOTを書き換えた後に元の正しいアドレスに修復したい場合、アドレス解決前に入っていた値(printf@plt+6など)を入れれば、次に呼ばれたときにアドレス解決されて正しいアドレスに修復される。

〇33.3.3 Return to libc(ret2libc)
・ライブラリ内にあるが元々使用していない関数は、PLTにないのでret2pltが使えず、ライブラリのアドレスリークをするしかない。
　アドレスリークにはGOTを読み出すのがよい。
・コード33-25：atoi()のアドレスをGOTからリークし、libcのバイナリからnmコマンドでatoi()のオフセットを取得すれば、libcのベースアドレスが分かる。
・atoi()コールでsystem()に飛ぶようにすれば、シェル実行ができる。ちょうどatoi(buf)でbufはfgets()で入力できるので、1 or 2を入力するときに/bin/shを入力すればいい。
・コード33-26：スタックの章の実践問題のexploitコードと似ている。
　　　　　　　binf.got['atoi']でGOTのアドレスを取得できる。
　　　　　　　binf.libcでlibcのバイナリ情報が取得できる。
　　　　　　　def aarとdef aawでAARとAAWを実行。
　　　　　　　attackの最初で、aaw()でexit()をmain()に飛ばすようにして、何回も実行できるようにする。
　　　　　　　次のaar()でatoi()のGOTからアドレスリーク。
　　　　　　　libc.addressにlibcのベースアドレスを設定。
　　　　　　　最後にaaw()でatoi()をsystem()に飛ばすようにして、その後にconn.sendlineafter()で/bin/shを入力。
・One-Gadget RCE
　system()を直接呼ぶのでなく、execve()やposix_spawn()を使っている関数を呼ぶことでシェル実行を簡単にする。
　one-gadgetというツールでそのようなガジェットを探してくれる。
　★前にglibのときに失敗した事例で、まさしくposix_spawn()でargvがNULLでエラーになってしまったことがあった気がする。

〇33.4章

〇33.4.1 RELROと遅延バインド
・RELRO有効であれば、.gotを含むいくつかのセクションが書き換え不可になる。
・RELROを有効にしても、遅延バインドが有効であればGOTの一部は書き換えできないと困るので、.got.pltというセクションで書き換えできるようにする。
　この状態をPartial RELROと呼ぶ。この場合はGOT Overwriteが可能になる。

〇33.5 実践問題
・コード33-37：スタックバッファオーバフロー＋任意アドレス書き込みの脆弱性
・コード33-38：カナリアあり。遅延バインドなのでPartial RELRO。-no-pieなのでこのプログラム自体のアドレスは分かる(libcのアドレスは不明)
・以下が必要
　- カナリアの回避：__stack_fail()でmain()に飛ぶようにする。これでカナリアを回避しつつ、何回も脆弱性を発生させられる。
　- libcのアドレスリーク：
　- system()呼び出し：

〇35章：

　- 本の35章
　　・%m$について
　　　⇒出力する引数の位置を指定できる
　　・%n(これまでに出力した文字数を引数のポインタに格納)について
　　　⇒漏洩だけでなく書き込みもできる
　　　⇒★一般的な使い方は？→printfの戻り値では全出力文字数しか分からないので、各引数ごとの出力文字数を知りたいときとかに使う？
　　・変換指定子のみで対応する引数が後ろにない場合
　　　⇒可変長引数の場合、引数の数のチェックがあるわけでもなく、呼ばれた側の関数では実際の引数の数は分からず、変換指定子を信じて、レジスタやスタックから引数値をとってくる。
　　　　引数が固定長であれば、レジスタやスタックから引数値をとる処理は固定で関数先頭のアセンブラに入っているが、可変長引数の場合は、まずは第一引数の変換指定子を見て、それから動的に引数値をとる。
　　　　※可変長引数のprintf()とかの関数内では、va_start()とかva_arg()を使って、名前がない引数を一つずつ取得していく。
　　　　　https://qiita.com/subaruf/items/657c67a1809515589a7c
　　・攻撃方法の整理
　　　- printf(const char *format, ...)
　　　- 前提：printf(buf)のように、外部から入力したデータをそのままprintf()に渡す。これ以外のパターンはふつうはないはず。あっても、printf()の第一引数は少なくとも外部から入力できないといけない。
　　　- ユースケース：サーバ側がncで-eオプションでプログラムを起動。
　　　- レジスタ、スタック(関数の呼び出し規約で引数が入る場所)のデータ漏洩ができる
　　　　⇒printf()が可変長引数で、引数の数は第一引数の変換指定子から判断するため、実際は引数が一つなのに任意の数の引数であると判断させられるため、上位関数が設定してないのにそこから値をとってくる。
　　　　⇒スタックの後ろのほうのデータをピンポイントで取得したい場合、%m$を使えばいい。
　　　　・bufのバッファがヒープで確保でなくローカル変数で確保の場合、任意のアドレスのデータ漏洩ができる
　　　　　⇒外部から入力したデータ自体がスタックに入っているので、外部からアドレスを入れて、%sで間接参照すればいい。
　　　　　⇒外部からアドレスを入れるときは、エンディアンと8byteアライメントに注意
　　　　　⇒アドレスを8byteで表したときに0(NULL)が入る場合、そこで変数指定子の文字列の終端と判断されてしまうため、アドレスは一番最後に入れる
　　　- 上記の任意のアドレスのデータ漏洩ができる場合は、任意のアドレスへの任意のデータ書き込みもできる
　　　　⇒%sを%nに変えればいいだけ。書き込めるデータはこれまでに出力した文字数なので、変換指定子の前の方に%258cとかを入れて出力文字数を調整する
　　　　　※%258cで実際にどういう文字が出力されるかというと、最小フィールド幅が258指定でフラグは指定されてないので、デフォルトの空白文字が258-1文字と、cで対応する引数の位置のデータ1文字が出力されるはず。
　　　　⇒4byteとか8byteの数値を書き込みたい場合は、1回で書こうとすると大量の文字が出力されてまずいので、1byteとか2byte単位で書き込むようにすべき
　　　- さらに、上記の任意のアドレスのデータ漏洩ができる場合に、スタック上の値を任意のアドレスへ書き込みもできる
　　　　⇒%258cのような固定値でなく、%*7$cのように*記号で最小フィールド幅を引数から指定すればよい
　　　　⇒スタック上の値にいくらか加えたり、何倍かしたりした値を書き込むことも可能
　　　　⇒ただし、スタック上の値がint型で負数の場合は負数からマイナスをとって正数にした値が書き込まれるので注意
　　　- bufのバッファがヒープで確保の場合、任意のアドレスへの書き込みはできないが、スタック上のポインタの先のデータの書き換えはできる
　　　　⇒スタック上のポインタそのままでなく、少しずらした位置のデータを書き換えるために、二段階で書き込みを行う場合(まずスタックの値を書き換えて、次に書き換えたスタックが指す先を書き換える)、
　　　　　1回目の書き換えで%m$を使ってはいけない。m$の書式が来た時点で引数の値を別の領域に複製して、以降そちらの値を使うため、スタックの値の書き換えが反映されないため。
　　　　　⇒この場合、%m$の代わりに%c%c%cと、指定したい引数の番目まで%cでずらす必要がある。
　　　　　⇒そもそも、この話は、スタック上にポインタと、そのポインタへのポインタの両方がある場合のみなので、かなり特殊なケースに思える。
　　　- 整理
　　　　・bufがヒープの場合
　　　　　- スタック上のデータ漏洩
　　　　　　⇒%m$pでスタック上のデータのそのままの値、%m$sで、ポインタが指している先の値が漏洩できる
　　　　　- スタック上のポインタが指している先の値の書き換え
　　　　　　⇒任意のデータでの書き換えは、%25c + %m$n、スタック上のデータでの書き換えは、%*m$ + %m$n。
　　　　・bufがスタックの場合
　　　　　- 任意のアドレスのデータ漏洩
　　　　　　⇒任意のアドレスをスタックに乗せられるので、%m$sでできる
　　　　　- 任意のアドレスのデータ値の書き換え
　　　　　　⇒任意のアドレスと任意のデータをスタックに乗せられるので、%25c + %m$n でも %*m$ + %m$n でもできる(どちらでも外部からデータを与えられるので同じ、一気に4byte書くと出力文字数が多くなる課題もどちらでも同じ)。
　　　　※スタックのデータを直接書き換えることはできない(スタック上にスタックへのポインタが入っていればできるが。)

〇35.4 実践問題
・-z lazyなので、GOT書き換えができる。-no-pieなのでGOTのアドレスも分かる。
・exit()をmain()に書き替えれば、複数回書式文字列攻撃ができる
・NX enabledなので、シェルコードのバイナリをスタックに置いて実行はできない。
・以下、答えを見た。
・任意のアドレスを任意の値で書き替えられるし、任意の情報漏洩もできる。
・ROPは使いずらい。スタックバッファオーバフローではないので。
・ただ、glibcのアドレスリークは書式文字列攻撃の方が簡単。
・printf()の引数に/bin/shを入れたらいいので、printf()のGOTをsystem()に変えればいい。
・つまり、1回目：exit()のGOTをmain()に書き換え
　　　　　2回目：glincの関数のアドレスリーク(read関数のアドレスがrcxレジスタにある)
　　　　　3回目：printf()のGOTをsystem()に書き換え
　　　　　4回目：/bin/shを入力
・ポイントとしては、buf[]のサイズ制限があるので、GOTを書き換えるときに%hhnで1byteずつではなく、%hnの2byte書き込みも含める。


